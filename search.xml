<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[学无止境，勤为径！]]></title>
      <url>%2Fposts%2F51adfd72%2F</url>
      <content type="text"><![CDATA[千里之行，始于足下！ 始 经过几天的努力，终于将这个博客搭建起来了，中间有太多的波折言之不尽，所辛都一一解决了，hexo、git、github、Markdown、域名、虚拟主机…等等，也收获了诸多知识。总之就是不亏，哈哈。。。 行 搭建只是开始，内容才是王道，希望以后能一点一滴地将这个博客丰富起来，才难对得起今天的努力和初衷。加油吧，少年。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC连接池]]></title>
      <url>%2Fposts%2F43bc44cc%2F</url>
      <content type="text"><![CDATA[有这样的一种现象： 用java代码操作数据库，需要数据库连接对象，一个用户至少要用到一个连接。现在假设有成千上百万个用户，就要创建十分巨大数量的连接对象，这会使数据库承受极大的压力，为了解决这种现象，一种技术出现了，这就是数据库连接池。 什么是数据库连接池（原理）所谓数据库连接池，可以看作 ：在用户和数据库之间创建一个”池”，这个池中有若干个连接对象，当用户想要连接数据库，就要先从连接池中获取连接对象，然后操作数据库。一旦连接池中的连接对象被拿光了，下一个想要操作数据库的用户必须等待，等待其他用户释放连接对象，把它放回连接池中，这时候等待的用户才能获取连接对象，从而操作数据库。 数据库连接池的属性连接对象初始的数量：initSize，一开始就创建若干个，当不够时再添加 连接对象最大数量：maxSize，添加到最大值则不会再添加下面我们用代码下一个自己的连接池吧~ 实现自己的连接池 看下面代码和注释吧~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class MyPool &#123; //设置注册属性 private String url = "jdbc:mysql://localhost:3306/vmaxtam"; private String user = "root"; private String password = "root"; private static String driverClass="com.mysql.jdbc.Driver"; //设置连接池属性 private int initSize = 5; private int maxSize = 8; //用LinkedList对象来保存connection对象 private LinkedList&lt;Connection&gt; connList = new LinkedList&lt;Connection&gt;(); //声明一个临时变量来计算连接对象的数量 private int currentsize = 0; //声明MyPool对象时自动注册驱动 static&#123; try &#123; Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //获取连接的方法 private Connection getConnection() &#123; Connection conn=null; try &#123; conn = DriverManager.getConnection(url, user, password); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return conn; &#125; //构造方法，初始化连接池，并往里面添加连接对象 public MyPool() &#123; for(int i = 0; i &lt; initSize; i++) &#123; Connection connection = this.getConnection(); connList.add(connection); currentsize++; &#125; &#125; //获取连接池中的一个连接对象 public Connection getConnFromPool() &#123; //当连接池还没空 if(connList.size()&gt;0)&#123; Connection connection = connList.getFirst(); connList.removeFirst(); return connection; &#125;else if(connList.size()==0&amp;&amp;currentsize&lt;8)&#123; //连接池被拿空，且连接数没有达到上限，创建新的连接 currentsize++; connList.addLast(this.getConnection()); Connection connection = connList.getFirst(); connList.removeFirst(); return connection; &#125; throw new RuntimeException("连接数达到上限，请等待"); &#125; //把用完的连接放回连接池 public void releaseConnection(Connection connection) &#123; connList.addLast(connection); &#125; &#125; 有了连接池后，我们写一个测试来调用一下它吧~123456789101112131415161718192021@Test public void test1() &#123; //获得连接池 MyPool mypool = new MyPool(); /*从连接池中尝试获取9个连接 for(int i = 0 ; i&lt;9; i++)&#123; Connection conn = mypool.getConnFromPool(); System.out.println(conn.toString()); &#125;*/ //获取第五个连接后，释放一下，然后再获取 for(int i = 0 ; i&lt;9; i++)&#123; Connection conn = mypool.getConnFromPool(); if(i==5)&#123; mypool.releaseConnection(conn); &#125; System.out.println(conn.toString()); &#125; &#125; 上面这样就实现了自己的一个连接池，但是这个连接池依然存在着很多问题，一个较为明显的问题就是： 如果一个用户获取了一个连接对象，然后调用了close()方法把它关闭了，没有放回池中，这样池中的这个对象就回不来了，造成最大连接上限为8个的连接池实际上只有7个连接在工作。 为了解决这个问题，我们需要对close()方法进行改造，是用户调用close()方法时，实际上是把连接放回连接池中，而不是关闭它。 下面就为解决这个问题来分析下~ 解决用户调用close()方法关闭连接 使用静态代理，写一个myConnection()类来继承connection的实现类，然后重写它的close()方法. 使用动态代理，使用jdbc动态代理类：java.lang.reflect.Proxy类参数解析： ClassLoader:类加载器，只要在同一个JDK中的类即可 Class&lt;?&gt;[]:要代理的接口的集合 InvocationHandler：代理接口的方法处理器 根据需要，我们要给MyPool中的Connection加一个动态代理，所以我们用的前两个参数是：MyPool.Class.GetClassLoader 与 new Class&lt;&gt;{Connection}最后还剩方法处理器，我们要修改Connection中的close方法，所以我们写出一个这样做的处理器即可，具体实现看下面代码与注释~1234567891011121314151617181920212223242526272829303132333435363738//获取连接的方法 private Connection getConnection() &#123; try &#123; //获取一个连接 final Connection conn=DriverManager.getConnection(url, user, password); //把连接交给动态代理类转换为代理的连接对象 Connection myconn = (Connection)Proxy.newProxyInstance( MyPool.class.getClassLoader(), new Class[] &#123;Connection.class&#125;, //编写一个方法处理器 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object value = null; //当遇到close方法，就会把对象放回连接池中，而不是关闭连接 if(method.getName().equals("close")) &#123; MyPool.connList.addLast(conn); &#125;else &#123; //其它方法不变 value = method.invoke(conn, args); &#125; return value; &#125;&#125; ); return myconn; &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; 以上就是利用动态代理的方式解决close的问题了~~但是，我们自己写的连接池还有很多其他问题： 当前多个并发用户同时获取连接时，可能拿到同一个连接对象 当前用户连接数超过了最大连接数时，不能直接抛出异常，应该有机制，控制用户等待时间…….. 所以，这时候已经有人站出来，为我们写好了一些功能相对完善的连接池，这些第三方的连接池得到了广泛的用途，下面我们来介绍一下常见的连接池工具吧~ DBCP连接池简介：DBCP连接池是开源组织Apache软件基金组织开发的连接池实现。 事实上，tomcat服务器默认就会使用这个连接池道具。 如何使用DBCP连接池呢，下面我来一一演示。 DBCP的使用步骤 导包，使用第三方的道具，必须导入相应的jar包。需要导入两个jar包： commons-dbcp-1.4.jar包 commons-pool-1.5.6.jar包 使用代码~看看下面代码的演示吧 1234567891011121314151617181920212223242526272829303132333435363738public class DBCPTest &#123; private String url = "jdbc:mysql://localhost:3306/vmaxtam"; private String user = "root"; private String password = "root"; private String classDriver = "com.mysql.jdbc.Driver"; @Test public void Test1() &#123; //创建DBCP连接池对象 BasicDataSource ds = new BasicDataSource(); //设置连接参数来进行连接 ds.setUrl(url); ds.setUsername(user); ds.setPassword(password); ds.setDriverClassName(classDriver); //然后可以设置连接池的一些属性啦~ ds.setInitialSize(5); ds.setMaxActive(8); ds.setMaxWait(3000);//设置最大的等待时长,毫秒为单位 //从连接池中获取对象 for(int i = 0 ; i&lt;8;i++) &#123; Connection conn = null; try &#123; conn = ds.getConnection(); System.out.println(conn.hashCode()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 为了测试效果，我们可以在循环中设置拿9个连接额，这样在拿第九个连接时就会出现等待，等待到结束都没有连接被释放回连接池，就会出现报错。 也可以把For循环改成下面那样，测试close方法：12345678910111213141516//从连接池中获取对象 for(int i = 0 ; i&lt;9;i++) &#123; Connection conn = null; try &#123; conn = ds.getConnection(); System.out.println(conn.hashCode()); if(i==5) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 上面的代码还是有点地方可以得到优化，例如可以通过配置文件来配置连接的参数，还有数据库连接池的属性参数。 配置文件： url=jdbc:mysql://localhost:3306/vmaxtam username=root password=root classDriver=com.mysql.jdbc.Driver initialSize=5 maxActive=8 maxWait=3000 用对象读取配置文件： 1234567891011121314151617181920212223@Test public void Test2() &#123; try &#123; //创建配置对象 Properties properties = new Properties(); properties.load(DBCPTest.class.getResourceAsStream("/dbcp.properties")); //创建连接池对象，并且用连接池工厂来加载配置对象的信息 BasicDataSource ds = (BasicDataSource)BasicDataSourceFactory.createDataSource(properties); //从连接池中获取对象 for(int i = 0 ; i&lt;8;i++) &#123; Connection conn = null; conn = ds.getConnection(); System.out.println(conn.hashCode()); &#125; &#125;catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; 以上就是DBCP连接池的基本用法了~下面我们来学习另一个连接池~ C3P0连接池 简介： C3P0是一个开源组织的产品，开源框架的内部的连接池一般都使用C3P0来实现，例如：Hibernate C3P0的使用步骤 导包，使用第三方的工具必须导入jar包,要导入的包： c3p0-0.9.1.2.jar 包 看下面的代码显示怎么使用这个连接池吧~ 1234567891011121314151617181920212223242526272829@Test public void Test1() &#123; try &#123; //获取连接池对象 ComboPooledDataSource cp = new ComboPooledDataSource(); //设置连接参数 cp.setJdbcUrl(url); cp.setUser(user); cp.setPassword(password); cp.setDriverClass(classDriver); //设置连接池的参数 cp.setInitialPoolSize(5);//初始数量 cp.setMaxPoolSize(8);//最大数量 cp.setCheckoutTimeout(3000);//最大等待时间 for(int i = 0 ; i&lt;8 ; i++) &#123; Connection conn = cp.getConnection(); System.out.println(conn.hashCode()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 可以看出，C3P0的用法和DBCP的用法非常的相似~这里不做累赘。 特别的是C3PO读取参数文件的方式，C3P0除了能像DBCP那样读取配置文件，它还提供了一种特殊的设置参数的方式，就是把参数数据写在一个名叫c3p0-config.xml的XML文件中，在创建C3P0对象时会自动在classpath去寻找该文件来读取~ 也就是说:c3p0会到classpath下读取名字为c3p0-config.xml文件 这份XML文件有特殊的要求，下面我们来写一下这份XML文件: 1234567891011121314151617181920212223242526272829&lt;c3p0-config&gt; &lt;!-- 默认配置 --&gt; &lt;default-config&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/vmaxtam&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;8&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;!-- mysql的连接配置 --&gt; &lt;named-config name="mysql"&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/vmaxtam&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;8&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;/named-config&gt; &lt;!-- 使用 oracal就会用这份配置--&gt; &lt;!-- 也可以写其他数据库的配置 --&gt;&lt;/c3p0-config&gt; 写完xml文件，现在我们就读取它吧~123456789101112131415161718192021@Test public void Test2() &#123; try &#123; //获取连接池对象,写上参数就会去找xml文件找这个数据库的配置来读取，当无参时，就会使用默认设置。 ComboPooledDataSource cp = new ComboPooledDataSource("mysql"); for(int i = 0 ; i&lt;9 ; i++) &#123; Connection conn = cp.getConnection(); System.out.println(conn.hashCode()); if(i==5) &#123; conn.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 使用这种读取方法，显得代码十分简便]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm安装hexo卡住怎么办]]></title>
      <url>%2Fposts%2F89caf779%2F</url>
      <content type="text"><![CDATA[用npm安装话经常出现卡住而导致无法正常安装，解决办法就是修改npm的安装源，以下三种方法任选一个即可（正常的朋友不用执行这一步） 1. 通过config命令: npm config set registry http://registry.cnpmjs.orgnpm info underscore （如果上面配置正确这个命令会有字符串response） 2. 命令行指定 npm –registry http://registry.cnpmjs.org info underscore 3. 编辑 ~/.npmrc 加入下面内容 registry = http://registry.cnpmjs.org]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Idea构建Maven项目教程]]></title>
      <url>%2Fposts%2F3522aeda%2F</url>
      <content type="text"><![CDATA[1. 步骤一：配置Idea的maven插件 2. 步骤二：创建maven项目file–&gt;new–&gt;project 3. 步骤三：设置groupid，artifactId 4. 步骤四：设置maven配置 5. 步骤五：设置项目名 6. 步骤六：最后，finish完成构建7. 构建中遇到的问题： jar包下载缓慢解决方案，配置setting.xml为国内阿里云镜像，下载速度秒飞~~ &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;]]></content>
    </entry>

    
  
  
</search>
