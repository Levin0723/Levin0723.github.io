<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[SQL嵌套查询]]></title>
      <url>%2Fblogs%2F2017-02-18%2F30fce7cc.html</url>
      <content type="text"><![CDATA[使用一句SQL语句查出下图中学生平均分大于90的学生姓名 注意要考虑学生同名不同班问题，并且是每个学生不同科目的平均分，而不是所有的平均分 答案如下1234SELECT a.name FROM (SELECT AVG(s.`score`) AS avg_score,s.`name` FROM score AS s GROUP BY s.`name`,s.`class`) AS a WHERE a.avg_score&gt;90; 分析SELECT AVG(s.`score`) AS avg_score,s.`name` FROM score AS s GROUP BY s.`name`,s.`class` 这条嵌套语句是查询每个学生的平均分，结果如下图 然后再以该嵌套语句的结果作为一张表，取别名查平均分大于90的学生姓名，结果如下图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java解决约瑟夫环算法]]></title>
      <url>%2Fblogs%2F2017-02-18%2Fa878b2c2.html</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839public class Main &#123; public static void main(String[] args) &#123; //50个人，从第一个人开始数，数到3的人出列 countThree(50, 0, 3); &#125; /** * 约瑟夫环：已知n个人(以编号1，2，3...n分别表示)围坐在一张圆桌周围。 * 从编号为k的人开始报数，数到m的那个人出列;他的下一个人又从1开始报数， * 数到m的那个人又出列;依此规律重复下去，直到圆桌周围的人全部出列。 * * @param n 人的总数 * @param start 开始报数的序号，start &lt; n * @param m 出列的标记(可以大于n) */ private static void countThree(int n, int start, int m) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //初始化列表 for (int i = 1; i &lt;= n; i++) &#123; list.add(i); &#125; while (list.size() &gt; 0) &#123; //将前连个移入列表尾端 for (int j = 0; j &lt; m-1; j++) &#123; // list.remove(start)的返回值为list.get(start) // 这条语句是循环m-1次将list的前m-1个值移到list的最后面 list.add(list.remove(start)); &#125; // 在第m次时将该值移除 int out = list.remove(start); //打印出列的序号 System.out.println(out); &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS中样式覆盖优先级问题]]></title>
      <url>%2Fblogs%2F2017-02-18%2F756ea8e8.html</url>
      <content type="text"><![CDATA[层叠优先级是:浏览器缺省 &lt; 外部样式表 &lt; 内部样式表 &lt; 内联样式 其中样式表又有:类选择器 &lt; 类派生选择器 &lt; ID选择器 &lt; ID派生选择器 派生选择器以前叫上下文选择器，所以完整的层叠优先级是:浏览器缺省 &lt; 外部样式表 &lt; 外部样式表类选择器 &lt; 外部样式表类派生选择器 &lt; 外部样式表ID选择器 &lt; 外部样式表ID派生选择器 &lt; 内部样式表 &lt; 内部样式表类选择器 &lt; 内部样式表类派生选择器 &lt; 内部样式表ID选择器 &lt; 内部样式表ID派生选择器 &lt; 内联样式...共12个优先级]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Demo之自动回复机器人，基于MyBatis]]></title>
      <url>%2Fblogs%2F2017-02-16%2F9c80a3c5.html</url>
      <content type="text"><![CDATA[这是一个学习慕课网时的Demo,课程地址：http://www.imooc.com/learn/154,IDE为IntelliJ IDEA2016.2.5，数据库为MySQL5.7。 1.目录结构 2.数据库表 2.页面展示2.1主页面 发送同一指令可回复不同内容 2.2后台页面 分页显示，实现指令的单条删除、多选全选、批量删除，并可按指令名或描述来查询。 3.代码展示 CommandDao类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.levin0723.dao;import com.levin0723.bean.Command;import com.levin0723.bean.Page;import com.levin0723.db.DBAccess;import org.apache.ibatis.session.SqlSession;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class CommandDao &#123; //根据条件查询 通过Mybatis的方式,并分布显示 public List&lt;Command&gt; queryCommandList(String name, String description, Page page) &#123; DBAccess dbAccess = new DBAccess(); List&lt;Command&gt; commandList = new ArrayList&lt;Command&gt;(); SqlSession sqlSession = null; try &#123; sqlSession = dbAccess.getSqlSession(); Command Command = new Command(); Command.setName(name); Command.setDescription(description); Map&lt;String,Object&gt; parameter = new HashMap&lt;String,Object&gt;(); parameter.put("command",Command); parameter.put("page",page); commandList = sqlSession.selectList("Command.queryCommandList",parameter); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return commandList; &#125; //根据条件查询 通过Mybatis的方式 public List&lt;Command&gt; queryList(String name, String description) &#123; DBAccess dbAccess = new DBAccess(); List&lt;Command&gt; commandList = new ArrayList&lt;Command&gt;(); SqlSession sqlSession = null; try &#123; sqlSession = dbAccess.getSqlSession(); Command Command = new Command(); Command.setName(name); Command.setDescription(description); commandList = sqlSession.selectList("Command.queryList",Command); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return commandList; &#125; //根据ID条件删除单条记录 通过Mybatis的方式 public void deleteOne(int id) &#123; DBAccess dbAccess = new DBAccess(); SqlSession sqlSession = null; try &#123; sqlSession = dbAccess.getSqlSession(); sqlSession.delete("Command.deleteOne",id); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; //根据list&lt;ID&gt;条件删除多条记录 通过Mybatis的方式 public void deleteBatch(List&lt;Integer&gt; ids) &#123; DBAccess dbAccess = new DBAccess(); SqlSession sqlSession = null; try &#123; sqlSession = dbAccess.getSqlSession(); sqlSession.delete("Command.deleteBatch",ids); sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; //查询总指令数 public int count(String name, String description) &#123; DBAccess dbAccess = new DBAccess(); int count = 0; SqlSession sqlSession = null; try &#123; sqlSession = dbAccess.getSqlSession(); Command Command = new Command(); Command.setName(name); Command.setDescription(description); count = sqlSession.selectOne("Command.count",Command); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return count; &#125;&#125; QueryService类 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.levin0723.service;import com.levin0723.bean.Command;import com.levin0723.bean.Command_content;import com.levin0723.bean.Page;import com.levin0723.dao.CommandDao;import java.util.List;import java.util.Random;public class QueryService &#123; //根据条件查询 通过Mybatis的方式,并分布显示 public List&lt;Command&gt; getList(String name, String description, Page page) &#123; CommandDao commandDao = new CommandDao(); int totalNumber = commandDao.count(name,description); page.setTotalNumber(totalNumber); List&lt;Command&gt; commandList = commandDao.queryCommandList(name, description,page); return commandList; &#125; public String queryByCommand(String name) &#123; CommandDao commandDao = new CommandDao(); List&lt;Command&gt; commandList = null; if (name.equals("帮助")) &#123; commandList = commandDao.queryList(null, null); StringBuilder result = new StringBuilder(); for (Command command : commandList) &#123; result.append("回复【" + command.getName() + "】可查看-&gt;" + command.getDescription()); result.append("&lt;br/&gt;"); &#125; return result.toString(); &#125; commandList = commandDao.queryList(name, null); if (commandList.size() &gt; 0) &#123; List&lt;Command_content&gt; contentListlist = commandList.get(0).getContentList(); int i = new Random().nextInt(contentListlist.size()); return contentListlist.get(i).getContent(); &#125; return "客官，你没按套路出牌。。。我听不懂你说什么！"; &#125;&#125; ListServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.levin0723.servlet;import com.levin0723.bean.Command;import com.levin0723.bean.Page;import com.levin0723.service.QueryService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;import java.util.regex.Pattern;/** * 列表页面控制 * Created by levin0723 on 2017-2-13. */@WebServlet(name = "ListServlet", urlPatterns = "/List.action")public class ListServlet extends HttpServlet &#123; private static final long serialVersionUID = 9212185910486803440L; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置编码 request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); //从页面取值 String command = request.getParameter("command"); String description = request.getParameter("description"); //向页面传值 request.setAttribute("name", command); request.setAttribute("description", description); //分布 String currentPage = request.getParameter("currentPage"); Page page = new Page(); Pattern pattern = Pattern.compile("[0-9]&#123;1,9&#125;"); if (currentPage==null||!pattern.matcher(currentPage).matches())&#123; page.setCurrentPage(1); &#125;else &#123; page.setCurrentPage(Integer.valueOf(currentPage)); &#125; QueryService service = new QueryService(); List&lt;Command&gt; messageList = service.getList(command,description,page); request.setAttribute("messageList", messageList); request.setAttribute("page", page); //页面跳转 request.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125;&#125; MyBatis的主要xml配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="" value=""/&gt; &lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="daodao"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="message.xml"/&gt; &lt;mapper resource="command.xml"/&gt; &lt;mapper resource="command_content.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Command类对应的xml配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="Command"&gt; &lt;resultMap type="com.levin0723.bean.Command" id="CommandResult"&gt; &lt;id column="C_ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="NAME" jdbcType="VARCHAR" property="name"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;collection property="contentList" resultMap="CommandContent.ContentResult"/&gt; &lt;/resultMap&gt; &lt;!--按条件查询，并返回结果，并实现分布功能--&gt; &lt;select id="queryCommandList" parameterType="java.util.Map" resultMap="CommandResult"&gt; SELECT c.ID C_ID,c.NAME,c.DESCRIPTION FROM test.command c &lt;where&gt; &lt;if test="command.name!=null and !&amp;quot;&amp;quot;.equals(command.name.trim())"&gt;AND c.NAME=#&#123;command.name&#125;&lt;/if&gt; &lt;if test="command.description!=null and !&amp;quot;&amp;quot;.equals(command.description.trim())"&gt; AND c.DESCRIPTION LIKE '%' #&#123;command.description&#125; '%' &lt;/if&gt; &lt;/where&gt; ORDER BY c.ID LIMIT #&#123;page.dbIndex&#125;,#&#123;page.dbNumber&#125; &lt;/select&gt; &lt;!--按条件查询，并返回结果--&gt; &lt;select id="queryList" parameterType="com.levin0723.bean.Command" resultMap="CommandResult"&gt; SELECT c.ID C_ID,c.NAME,c.DESCRIPTION,cc.ID,cc.CONTENT,cc.COMMAND_ID FROM test.command c LEFT JOIN test.command_content cc ON c.ID = cc.COMMAND_ID &lt;where&gt; &lt;if test="name!=null and !&amp;quot;&amp;quot;.equals(name.trim())"&gt;AND c.NAME=#&#123;name&#125;&lt;/if&gt; &lt;if test="description!=null and !&amp;quot;&amp;quot;.equals(description.trim())"&gt;AND c.DESCRIPTION LIKE '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--按条件查询，并返回结果总数--&gt; &lt;select id="count" parameterType="com.levin0723.bean.Command" resultType="int"&gt; SELECT COUNT(*) FROM test.command c &lt;where&gt; &lt;if test="name!=null and !&amp;quot;&amp;quot;.equals(name.trim())"&gt;AND c.NAME=#&#123;name&#125;&lt;/if&gt; &lt;if test="description!=null and !&amp;quot;&amp;quot;.equals(description.trim())"&gt;AND c.DESCRIPTION LIKE '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--单个删除--&gt; &lt;delete id="deleteOne" parameterType="int"&gt; DELETE FROM test.command WHERE ID = #&#123;_parameter&#125; &lt;/delete&gt; &lt;!--批量删除--&gt; &lt;delete id="deleteBatch" parameterType="java.util.List"&gt; DELETE FROM test.command WHERE ID IN( &lt;foreach collection="list" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/delete&gt;&lt;/mapper&gt; 更多代码 请前往https://github.com/Levin0723/Demo/tree/master/Test02/wechatAutoRepeat下载查看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Demo之小商城，基于severlet和MySQL]]></title>
      <url>%2Fblogs%2F2017-02-16%2F8b93bba4.html</url>
      <content type="text"><![CDATA[这是一个学习慕课网时的Demo,课程地址：http://www.imooc.com/learn/166,IDE为IntelliJ IDEA2016.2.5，数据库为MySQL5.7。 目录结构 页面展示商城页面 商品页面 实现加入购物车、查看购物车，查看最近浏览的商品 购物车页面 实现计算总金额、删除商品 代码展示 CartServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package servlet;import dao.ItemsDAO;import entity.Cart;import entity.Items;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by levin0723 on 2017-1-7. */@WebServlet(name = "CartServlet", urlPatterns = &#123;"/CartServlet"&#125;)public class CartServlet extends HttpServlet &#123; private String action; //购物车的动作 //商品业务逻辑类 ItemsDAO idao = new ItemsDAO(); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); if (request.getParameter("action") != null) &#123; this.action = request.getParameter("action"); if (action.equals("add")) &#123; //添加商品 if(addToCart(request, response))&#123; request.getRequestDispatcher("/success.jsp").forward(request,response); &#125;else &#123; request.getRequestDispatcher("/failure.jsp").forward(request,response); &#125; &#125; if (action.equals("show")) &#123; //显示商品 request.getRequestDispatcher("/cart.jsp").forward(request,response); &#125; if(action.equals("delete"))&#123; //删除商品 if(deleteFromCart(request,response))&#123; request.getRequestDispatcher("/cart.jsp").forward(request,response); &#125;else &#123; request.getRequestDispatcher("/cart.jsp").forward(request,response); &#125; &#125; &#125; &#125; //添加商品 private boolean addToCart(HttpServletRequest request, HttpServletResponse response) &#123; String id = request.getParameter("id"); String number = request.getParameter("num"); Items item = idao.getItemsById(Integer.parseInt(id)); //是否是第一次给购物车添加商品，需新建购物车对象 if (request.getSession().getAttribute("cart") == null) &#123; Cart cart = new Cart(); request.getSession().setAttribute("cart", cart); &#125; Cart cart = (Cart) request.getSession().getAttribute("cart"); if (cart.addGoodsInCart(item, Integer.parseInt(number))) &#123; return true; &#125; else &#123; return false; &#125; &#125; //从购物车中删除商品 private boolean deleteFromCart(HttpServletRequest request,HttpServletResponse responser)&#123; String id = request.getParameter("id"); Cart cart = (Cart) request.getSession().getAttribute("cart"); Items item = idao.getItemsById(Integer.parseInt(id)); if (cart.removeGoodsFromCart(item))&#123; return true; &#125;else &#123; return false;&#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125;&#125; 商品的业务逻辑类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package dao;import entity.Items;import util.DBHelper;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;/** * 商品的业务逻辑类 * Created by levin on 2017-1-4. */public class ItemsDAO &#123; //获取商品的所有信息 public ArrayList&lt;Items&gt; getAllItems() &#123; Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; ArrayList&lt;Items&gt; list = new ArrayList&lt;Items&gt;(); try &#123; conn = DBHelper.getConnection(); // 获取数据库连接 String sql = "SELECT * FROM imooc.items;"; //SQL语句 stmt = conn.prepareStatement(sql); // 预编译SQL语句 rs = stmt.executeQuery(); //执行SQL查询 返回结果集 while (rs.next()) &#123; Items item = new Items(); //新建商品类保存查询结果 item.setId(rs.getInt("id")); // 保存商品的各项属性 item.setName(rs.getString("name")); item.setCity(rs.getString("city")); item.setPrice(rs.getInt("price")); item.setNumber(rs.getInt("number")); item.setPicture(rs.getString("picture")); list.add(item); //将所得商品添加到结果集 &#125; return list; &#125; catch (SQLException e) &#123; e.printStackTrace(); return null; &#125; finally &#123; //清理工作 释放资源 if (rs != null || stmt != null) &#123; try &#123; rs.close(); rs = null; stmt.close(); stmt = null; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //获取最近浏览的前五条商品记录 public ArrayList&lt;Items&gt; getViewList(String list) &#123; ArrayList&lt;Items&gt; viewList = new ArrayList&lt;Items&gt;(); int count = 5; //返回前五条 if (list != null &amp;&amp; list.length() &gt; 0) &#123; String[] arr = list.split(","); if (arr.length &gt;= 5) &#123; for (int i = arr.length - 1; i &gt;= arr.length - count; i--) &#123; String s = arr[i]; int id = Integer.parseInt(s); viewList.add(getAllItems().get(id - 1)); &#125; &#125; else &#123; for (int i = arr.length - 1; i &gt;= 0; i--) &#123; String s = arr[i]; int id = Integer.parseInt(s); viewList.add(getAllItems().get(id - 1)); &#125; &#125; return viewList; &#125; else &#123; return null; &#125; &#125; // 根据商品编号获得商品资料 public Items getItemsById(int id) &#123; Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; conn = DBHelper.getConnection(); String sql = "select * from items where id=?;"; // SQL语句 stmt = conn.prepareStatement(sql); stmt.setInt(1, id); rs = stmt.executeQuery(); if (rs.next()) &#123; Items item = new Items(); item.setId(rs.getInt("id")); item.setName(rs.getString("name")); item.setCity(rs.getString("city")); item.setNumber(rs.getInt("number")); item.setPrice(rs.getInt("price")); item.setPicture(rs.getString("picture")); return item; &#125; else &#123; return null; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); return null; &#125; finally &#123; // 释放数据集对象 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 释放语句对象 if (stmt != null) &#123; try &#123; stmt.close(); stmt = null; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 更多代码 请前往http://pan.baidu.com/s/1qY2gdS4下载查看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Demo之网络留言板，基于severlet和filter]]></title>
      <url>%2Fblogs%2F2017-02-16%2Fae830a21.html</url>
      <content type="text"><![CDATA[这是一个学习慕课网时的Demo,IDE为IntelliJ IDEA2016.2.5，数据库为MySQL5.7。 目录结构 页面展示登录页面 支持帐号密码校验，非空提示，注册功能。 留言页面 代码展示 数据库连接类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package Util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;/** * 数据库连接类 * Created by levin0723 on 2017-1-4. */public class DBHelper &#123; //数据库驱动 private final static String DRIVER = "com.mysql.jdbc.Driver"; //连接数据库的URL地址 private final static String URL = "jdbc:mysql://localhost:3306/imooc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true"; //数据库的用户名 private final static String USERNAME = "root"; //数据库的密码 private final static String PASSWORD = "daodao"; //获取的数据库连接对象 private static Connection conn = null; //静态代码块负责加载驱动 static &#123; try &#123; //加载驱动程序 通过反射 Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //工厂模型的单例化 返回数据库转接对象 public static Connection getConnection()&#123; if(conn==null)&#123; try &#123; conn = DriverManager.getConnection(URL,USERNAME,PASSWORD); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; return conn; &#125;&#125; 登录servlet 1234567891011121314151617181920212223242526272829303132333435363738394041424344package servlet;import bean.Message;import bean.User;import dao.MessageDao;import dao.UserDao;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;/** * 登录servlet * Created by levin0723 on 2017-1-14. */@WebServlet(name = "loginServlet", urlPatterns = &#123;"/login"&#125;)public class loginServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); String username = request.getParameter("username"); String userPassword = request.getParameter("userPassword"); UserDao userDao = new UserDao(); User user = userDao.getUser(username, userPassword); if (user.getUserName()!=null) &#123; MessageDao messageDao = new MessageDao(); List&lt;Message&gt; list = messageDao.getMessage(); request.getSession().setAttribute("messageList",list); request.getSession().setAttribute("user", user); request.getRequestDispatcher("/message.jsp").forward(request, response); &#125;else &#123; response.sendRedirect("/index.jsp?do=register"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125;&#125; 用户逻辑类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package dao;import Util.DBHelper;import bean.User;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * 用户逻辑类 * Created by levin0723 on 2017-1-14. */public class UserDao &#123; Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; //根据用户和密码来查询用户信息 public User getUser(String name,String password)&#123; User user = new User(); String sql = "SELECT * FROM user_info WHERE userName = ? " + "AND userPassword = ? ;"; conn = DBHelper.getConnection(); try &#123; pstm = conn.prepareStatement(sql); pstm.setString(1,name); pstm.setString(2,password); rs = pstm.executeQuery(); while (rs.next())&#123; user.setUserId(rs.getInt("userId")); user.setUserName(rs.getString("userName")); user.setUserPassword(rs.getString("userPassword")); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; if (user!=null)&#123; return user; &#125;else &#123; return null; &#125; &#125; //注册用户 public int addUser(String name,String password)&#123; int i = 0; String sql = "INSERT INTO user_info(userName,userPassword) VALUES (?,?) ;"; conn = DBHelper.getConnection(); try &#123; pstm = conn.prepareStatement(sql); pstm.setString(1,name); pstm.setString(2,password); i = pstm.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i; &#125;&#125; 登录过滤 1234567891011121314151617181920212223242526272829303132333435package filter;import bean.User;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 登录过滤 * Created by levin0723 on 2017-1-16. */@WebFilter(filterName = "loginFilter",urlPatterns = &#123;"/message.jsp"&#125;)public class loginFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; HttpServletRequest request = (HttpServletRequest) req; User user = (User) request.getSession().getAttribute("user"); if (user!=null)&#123; chain.doFilter(req, resp); &#125;else &#123; HttpServletResponse response = (HttpServletResponse) resp; response.sendRedirect("/index.jsp?do=register"); &#125; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 更多代码 请前往https://github.com/Levin0723/Demo/tree/master/MessageBoardDemo下载查看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Demo之后台管理系统，基于Struts2和Hibernate]]></title>
      <url>%2Fblogs%2F2017-02-16%2F8e2d1468.html</url>
      <content type="text"><![CDATA[这是一个学习慕课网时的Demo,课程地址：http://www.imooc.com/learn/466，IDE为IntelliJ IDEA2016.2.5，数据库为MySQL5.7,项目管理为maven。 1.目录结构 2.页面演示2.1登录界面 支持帐号密码校验，非空提示。 2.2后台学生管理界面 支持学生的增加、修改、删除、查询，后台界面可退出登录 2.3 后台老师即用户管理界面 支持用户的增加、修改、删除、查询，后台界面可退出登录 3.代码展示3.1全部代码 全部代码地址：https://github.com/Levin0723/Demo/tree/master/Struts2AndHibernateDemo 3.2部分代码 HibernateSessionFactory工具类 1234567891011121314151617181920212223242526272829package util;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;/** * HibernateSessionFactory工具类 * Created by Levin0723 on 2017-1-20. */public class MyHibernateSessionFactory &#123; private static SessionFactory mySessionFactory; //私有化构造方法，保证单例化模式 private MyHibernateSessionFactory() &#123; &#125; //公有方法，获取公话工厂对象 public static SessionFactory getSessionFactory() &#123; if (mySessionFactory == null) &#123; Configuration configuration = new Configuration().configure(); mySessionFactory = configuration.buildSessionFactory(); return mySessionFactory; &#125; else &#123; return mySessionFactory; &#125; &#125;&#125; 用户Action动作类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package action;import com.opensymphony.xwork2.ModelDriven;import entity.Users;import org.apache.struts2.interceptor.validation.SkipValidation;import service.UsersDao;import serviceImpl.UsersDaoImpl;import java.text.ParseException;import java.util.List;/** * 用户Action动作类 * Created by levino723 on 2017-1-24. */public class UsersAction extends SuperAction implements ModelDriven&lt;Users&gt; &#123; private static final long serialVersionUID = 4317500994450323565L; private Users user = new Users(); public Users getModel() &#123; return this.user; &#125; //用户登录动作 public String login() &#123; UsersDao udao = new UsersDaoImpl(); if (udao.usersLogin(user)) &#123; //在session中保存用户名 session.setAttribute("loginUserName",user.getUsername()); return "login_success"; &#125; else &#123; this.addFieldError("loginError","用户名或密码不正确！"); return "login_failure"; &#125; &#125; @SkipValidation //用户退出登录动作,不用表单验证 public String logout() &#123; if (session.getAttribute("loginUserName")!=null) &#123; //在session中保存用户名 session.removeAttribute("loginUserName"); session.removeAttribute("users_list"); session.removeAttribute("get_user"); &#125; return "logout_success"; &#125; @SkipValidation //查询所有用户资料 public String queryAllUsers() &#123; UsersDao udao = new UsersDaoImpl(); List&lt;Users&gt; list = udao.queryAllUsers(); if (list != null &amp;&amp; list.size() &gt; 0) &#123; session.setAttribute("users_list", list); &#125; return "user_query_all_success"; &#125; @SkipValidation //根据用户编号查询单个用户资料 public String getUser() &#123; UsersDao udao = new UsersDaoImpl(); Users user = udao.queryUserById(Integer.parseInt(request.getParameter("uid"))); //保存在会话中 session.setAttribute("get_user",user); return "get_user_success"; &#125; @SkipValidation //添加用户 public String addUser() throws ParseException &#123; UsersDao udao = new UsersDaoImpl(); String uname = request.getParameter("username"); String password = request.getParameter("password"); Users user = new Users(uname,password); udao.addUser(user); return "add_succeed"; &#125; @SkipValidation //修改用户资料 public String update() throws ParseException &#123; UsersDao udao = new UsersDaoImpl(); int uid = ((Users) session.getAttribute("get_user")).getUid(); String uname = request.getParameter("username"); String password = request.getParameter("password"); Users user = new Users(uid,uname,password); udao.updateUser(user); return "update_success"; &#125; @SkipValidation //删除用户 public String delete() &#123; UsersDao udao = new UsersDaoImpl(); int uid = Integer.parseInt(request.getParameter("uid")); udao.deleteUser(uid); return "delete_success"; &#125; //表单验证 @Override public void validate() &#123; //用户名不能为空 if ("".equals(user.getUsername().trim()))&#123; this.addFieldError("usernameError","用户名不能为空!"); &#125; //密码不能为空 if ("".equals(user.getPassword().trim()))&#123; this.addFieldError("passwordError","密码不能为空!"); &#125; &#125;&#125; 用户逻辑实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package serviceImpl;import entity.Users;import org.hibernate.Session;import org.hibernate.Transaction;import org.hibernate.query.Query;import service.UsersDao;import util.MyHibernateSessionFactory;import java.util.List;/** *用户逻辑实现类 * Created by levin0723 on 2017-1-23. */public class UsersDaoImpl implements UsersDao &#123; //用户登录实现方法 public boolean usersLogin(Users user) &#123; //事务对象 Transaction tx = null; String hql = ""; try &#123; Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession(); tx = session.beginTransaction(); hql = "from Users where username=? and password=? "; Query query = session.createQuery(hql); query.setParameter(0,user.getUsername()); query.setParameter(1,user.getPassword()); List lists = query.list(); tx.commit(); return lists.size() &gt; 0; &#125;catch (Exception ex)&#123; return false; &#125;finally &#123; tx = null; &#125; &#125; //查询所有用户资料 public List&lt;Users&gt; queryAllUsers() &#123; Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession(); Transaction ts = session.beginTransaction(); String hql = "select new Users (uid,username,password) from Users "; Query query = session.createQuery(hql); List&lt;Users&gt; list = query.list(); ts.commit(); return list; &#125; //根据用户编号查询单个学生资料 public Users queryUserById(int uid) &#123; Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession(); Transaction ts = session.beginTransaction(); Users user = session.get(Users.class,uid); ts.commit(); return user; &#125; //添加用户 public boolean addUser(Users u) &#123; Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession(); Transaction ts = session.beginTransaction(); session.save(u); ts.commit(); return true; &#125; //修改用户资料 public boolean updateUser(Users u) &#123; Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession(); Transaction ts = session.beginTransaction(); session.update(u); ts.commit(); return true; &#125; //删除用户 public boolean deleteUser(int uid) &#123; Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession(); Transaction ts = session.beginTransaction(); Users user = session.get(Users.class,uid); session.delete(user); ts.commit(); return true; &#125;&#125; Hibernate的xml配置文件 1234567891011121314151617181920212223&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="connection.username"&gt;root&lt;/property&gt; &lt;property name="connection.password"&gt;daodao&lt;/property&gt; &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="connection.url"&gt;jdbc:mysql:///test2?useSSL=true&lt;/property&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;property name="format_sql"&gt;false&lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;mapping class="entity.Students"/&gt; &lt;mapping class="entity.Users"/&gt; &lt;!-- DB schema will be updated if needed --&gt; &lt;!-- &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; --&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; Struts2的xml配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;package name="default" extends="struts-default" namespace="/"&gt; &lt;/package&gt; &lt;!-- 用户相关包 --&gt; &lt;package name="users" namespace="/users" extends="default"&gt; &lt;action name="*_*" class="action.&#123;1&#125;Action" method="&#123;2&#125;"&gt; &lt;result name="login_success"&gt;/users/Users_login_success.jsp&lt;/result&gt; &lt;result name="login_failure"&gt;/users/Users_login.jsp&lt;/result&gt; &lt;result name="logout_success"&gt;/users/Users_login.jsp&lt;/result&gt; &lt;result name="input"&gt;/users/Users_login.jsp&lt;/result&gt; &lt;result name="user_query_all_success"&gt;/users/Users_query_success.jsp&lt;/result&gt; &lt;result name="delete_success" type="chain"&gt;Users_queryAllUsers&lt;/result&gt; &lt;result name="add_succeed"&gt;/users/Users_add_success.jsp&lt;/result&gt; &lt;result name="get_user_success"&gt;/users/Users_getUser.jsp&lt;/result&gt; &lt;result name="update_success"&gt;/users/Users_update_success.jsp&lt;/result&gt; &lt;allowed-methods&gt;login,logout,queryAllUsers,delete,addUser,update,getUser&lt;/allowed-methods&gt; &lt;/action&gt; &lt;/package&gt; &lt;!-- 学生相关包 --&gt; &lt;package name="students" namespace="/students" extends="default"&gt; &lt;action name="*_*" class="action.&#123;1&#125;Action" method="&#123;2&#125;"&gt; &lt;result name="student_query_all_success"&gt;/students/Students_query_success.jsp&lt;/result&gt; &lt;result name="delete_success" type="chain"&gt;Students_queryAllStudnets&lt;/result&gt; &lt;result name="add_succeed"&gt;/students/Students_add_success.jsp&lt;/result&gt; &lt;result name="get_student_success"&gt;/students/Students_getStudent.jsp&lt;/result&gt; &lt;result name="update_success"&gt;/students/Students_update_success.jsp&lt;/result&gt; &lt;allowed-methods&gt;queryAllStudnets,delete,addStudent,update,getStudent&lt;/allowed-methods&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 3.3更多代码 请前往https://github.com/Levin0723/Demo/tree/master/Struts2AndHibernateDemo下载查看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学无止境，勤为径！]]></title>
      <url>%2Fblogs%2F2017-02-11%2F51adfd72.html</url>
      <content type="text"><![CDATA[千里之行，始于足下！ 始 经过几天的努力，终于将这个博客搭建起来了，中间有太多的波折言之不尽，所辛都一一解决了，hexo、git、github、Markdown、域名、虚拟主机…等等，也收获了诸多知识。总之就是不亏，哈哈。。。 行 搭建只是开始，内容才是王道，希望以后能一点一滴地将这个博客丰富起来，才难对得起今天的努力和初衷。加油吧，少年。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC连接池]]></title>
      <url>%2Fblogs%2F2017-02-11%2F43bc44cc.html</url>
      <content type="text"><![CDATA[有这样的一种现象： 用java代码操作数据库，需要数据库连接对象，一个用户至少要用到一个连接。现在假设有成千上百万个用户，就要创建十分巨大数量的连接对象，这会使数据库承受极大的压力，为了解决这种现象，一种技术出现了，这就是数据库连接池。 什么是数据库连接池（原理）所谓数据库连接池，可以看作 ：在用户和数据库之间创建一个”池”，这个池中有若干个连接对象，当用户想要连接数据库，就要先从连接池中获取连接对象，然后操作数据库。一旦连接池中的连接对象被拿光了，下一个想要操作数据库的用户必须等待，等待其他用户释放连接对象，把它放回连接池中，这时候等待的用户才能获取连接对象，从而操作数据库。 数据库连接池的属性连接对象初始的数量：initSize，一开始就创建若干个，当不够时再添加 连接对象最大数量：maxSize，添加到最大值则不会再添加下面我们用代码下一个自己的连接池吧~ 实现自己的连接池 看下面代码和注释吧~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class MyPool &#123; //设置注册属性 private String url = "jdbc:mysql://localhost:3306/vmaxtam"; private String user = "root"; private String password = "root"; private static String driverClass="com.mysql.jdbc.Driver"; //设置连接池属性 private int initSize = 5; private int maxSize = 8; //用LinkedList对象来保存connection对象 private LinkedList&lt;Connection&gt; connList = new LinkedList&lt;Connection&gt;(); //声明一个临时变量来计算连接对象的数量 private int currentsize = 0; //声明MyPool对象时自动注册驱动 static&#123; try &#123; Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //获取连接的方法 private Connection getConnection() &#123; Connection conn=null; try &#123; conn = DriverManager.getConnection(url, user, password); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return conn; &#125; //构造方法，初始化连接池，并往里面添加连接对象 public MyPool() &#123; for(int i = 0; i &lt; initSize; i++) &#123; Connection connection = this.getConnection(); connList.add(connection); currentsize++; &#125; &#125; //获取连接池中的一个连接对象 public Connection getConnFromPool() &#123; //当连接池还没空 if(connList.size()&gt;0)&#123; Connection connection = connList.getFirst(); connList.removeFirst(); return connection; &#125;else if(connList.size()==0&amp;&amp;currentsize&lt;8)&#123; //连接池被拿空，且连接数没有达到上限，创建新的连接 currentsize++; connList.addLast(this.getConnection()); Connection connection = connList.getFirst(); connList.removeFirst(); return connection; &#125; throw new RuntimeException("连接数达到上限，请等待"); &#125; //把用完的连接放回连接池 public void releaseConnection(Connection connection) &#123; connList.addLast(connection); &#125; &#125; 有了连接池后，我们写一个测试来调用一下它吧~123456789101112131415161718192021@Test public void test1() &#123; //获得连接池 MyPool mypool = new MyPool(); /*从连接池中尝试获取9个连接 for(int i = 0 ; i&lt;9; i++)&#123; Connection conn = mypool.getConnFromPool(); System.out.println(conn.toString()); &#125;*/ //获取第五个连接后，释放一下，然后再获取 for(int i = 0 ; i&lt;9; i++)&#123; Connection conn = mypool.getConnFromPool(); if(i==5)&#123; mypool.releaseConnection(conn); &#125; System.out.println(conn.toString()); &#125; &#125; 上面这样就实现了自己的一个连接池，但是这个连接池依然存在着很多问题，一个较为明显的问题就是： 如果一个用户获取了一个连接对象，然后调用了close()方法把它关闭了，没有放回池中，这样池中的这个对象就回不来了，造成最大连接上限为8个的连接池实际上只有7个连接在工作。 为了解决这个问题，我们需要对close()方法进行改造，是用户调用close()方法时，实际上是把连接放回连接池中，而不是关闭它。 下面就为解决这个问题来分析下~ 解决用户调用close()方法关闭连接 使用静态代理，写一个myConnection()类来继承connection的实现类，然后重写它的close()方法. 使用动态代理，使用jdbc动态代理类：java.lang.reflect.Proxy类参数解析： ClassLoader:类加载器，只要在同一个JDK中的类即可 Class&lt;?&gt;[]:要代理的接口的集合 InvocationHandler：代理接口的方法处理器 根据需要，我们要给MyPool中的Connection加一个动态代理，所以我们用的前两个参数是：MyPool.Class.GetClassLoader 与 new Class&lt;&gt;{Connection}最后还剩方法处理器，我们要修改Connection中的close方法，所以我们写出一个这样做的处理器即可，具体实现看下面代码与注释~1234567891011121314151617181920212223242526272829303132333435363738//获取连接的方法 private Connection getConnection() &#123; try &#123; //获取一个连接 final Connection conn=DriverManager.getConnection(url, user, password); //把连接交给动态代理类转换为代理的连接对象 Connection myconn = (Connection)Proxy.newProxyInstance( MyPool.class.getClassLoader(), new Class[] &#123;Connection.class&#125;, //编写一个方法处理器 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object value = null; //当遇到close方法，就会把对象放回连接池中，而不是关闭连接 if(method.getName().equals("close")) &#123; MyPool.connList.addLast(conn); &#125;else &#123; //其它方法不变 value = method.invoke(conn, args); &#125; return value; &#125;&#125; ); return myconn; &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; 以上就是利用动态代理的方式解决close的问题了~~但是，我们自己写的连接池还有很多其他问题： 当前多个并发用户同时获取连接时，可能拿到同一个连接对象 当前用户连接数超过了最大连接数时，不能直接抛出异常，应该有机制，控制用户等待时间…….. 所以，这时候已经有人站出来，为我们写好了一些功能相对完善的连接池，这些第三方的连接池得到了广泛的用途，下面我们来介绍一下常见的连接池工具吧~ DBCP连接池简介：DBCP连接池是开源组织Apache软件基金组织开发的连接池实现。 事实上，tomcat服务器默认就会使用这个连接池道具。 如何使用DBCP连接池呢，下面我来一一演示。 DBCP的使用步骤 导包，使用第三方的道具，必须导入相应的jar包。需要导入两个jar包： commons-dbcp-1.4.jar包 commons-pool-1.5.6.jar包 使用代码~看看下面代码的演示吧 1234567891011121314151617181920212223242526272829303132333435363738public class DBCPTest &#123; private String url = "jdbc:mysql://localhost:3306/vmaxtam"; private String user = "root"; private String password = "root"; private String classDriver = "com.mysql.jdbc.Driver"; @Test public void Test1() &#123; //创建DBCP连接池对象 BasicDataSource ds = new BasicDataSource(); //设置连接参数来进行连接 ds.setUrl(url); ds.setUsername(user); ds.setPassword(password); ds.setDriverClassName(classDriver); //然后可以设置连接池的一些属性啦~ ds.setInitialSize(5); ds.setMaxActive(8); ds.setMaxWait(3000);//设置最大的等待时长,毫秒为单位 //从连接池中获取对象 for(int i = 0 ; i&lt;8;i++) &#123; Connection conn = null; try &#123; conn = ds.getConnection(); System.out.println(conn.hashCode()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 为了测试效果，我们可以在循环中设置拿9个连接额，这样在拿第九个连接时就会出现等待，等待到结束都没有连接被释放回连接池，就会出现报错。 也可以把For循环改成下面那样，测试close方法：12345678910111213141516//从连接池中获取对象 for(int i = 0 ; i&lt;9;i++) &#123; Connection conn = null; try &#123; conn = ds.getConnection(); System.out.println(conn.hashCode()); if(i==5) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 上面的代码还是有点地方可以得到优化，例如可以通过配置文件来配置连接的参数，还有数据库连接池的属性参数。 配置文件： url=jdbc:mysql://localhost:3306/vmaxtam username=root password=root classDriver=com.mysql.jdbc.Driver initialSize=5 maxActive=8 maxWait=3000 用对象读取配置文件： 1234567891011121314151617181920212223@Test public void Test2() &#123; try &#123; //创建配置对象 Properties properties = new Properties(); properties.load(DBCPTest.class.getResourceAsStream("/dbcp.properties")); //创建连接池对象，并且用连接池工厂来加载配置对象的信息 BasicDataSource ds = (BasicDataSource)BasicDataSourceFactory.createDataSource(properties); //从连接池中获取对象 for(int i = 0 ; i&lt;8;i++) &#123; Connection conn = null; conn = ds.getConnection(); System.out.println(conn.hashCode()); &#125; &#125;catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; 以上就是DBCP连接池的基本用法了~下面我们来学习另一个连接池~ C3P0连接池 简介： C3P0是一个开源组织的产品，开源框架的内部的连接池一般都使用C3P0来实现，例如：Hibernate C3P0的使用步骤 导包，使用第三方的工具必须导入jar包,要导入的包： c3p0-0.9.1.2.jar 包 看下面的代码显示怎么使用这个连接池吧~ 1234567891011121314151617181920212223242526272829@Test public void Test1() &#123; try &#123; //获取连接池对象 ComboPooledDataSource cp = new ComboPooledDataSource(); //设置连接参数 cp.setJdbcUrl(url); cp.setUser(user); cp.setPassword(password); cp.setDriverClass(classDriver); //设置连接池的参数 cp.setInitialPoolSize(5);//初始数量 cp.setMaxPoolSize(8);//最大数量 cp.setCheckoutTimeout(3000);//最大等待时间 for(int i = 0 ; i&lt;8 ; i++) &#123; Connection conn = cp.getConnection(); System.out.println(conn.hashCode()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 可以看出，C3P0的用法和DBCP的用法非常的相似~这里不做累赘。 特别的是C3PO读取参数文件的方式，C3P0除了能像DBCP那样读取配置文件，它还提供了一种特殊的设置参数的方式，就是把参数数据写在一个名叫c3p0-config.xml的XML文件中，在创建C3P0对象时会自动在classpath去寻找该文件来读取~ 也就是说:c3p0会到classpath下读取名字为c3p0-config.xml文件 这份XML文件有特殊的要求，下面我们来写一下这份XML文件: 1234567891011121314151617181920212223242526272829&lt;c3p0-config&gt; &lt;!-- 默认配置 --&gt; &lt;default-config&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/vmaxtam&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;8&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;!-- mysql的连接配置 --&gt; &lt;named-config name="mysql"&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/vmaxtam&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;8&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;/named-config&gt; &lt;!-- 使用 oracal就会用这份配置--&gt; &lt;!-- 也可以写其他数据库的配置 --&gt;&lt;/c3p0-config&gt; 写完xml文件，现在我们就读取它吧~123456789101112131415161718192021@Test public void Test2() &#123; try &#123; //获取连接池对象,写上参数就会去找xml文件找这个数据库的配置来读取，当无参时，就会使用默认设置。 ComboPooledDataSource cp = new ComboPooledDataSource("mysql"); for(int i = 0 ; i&lt;9 ; i++) &#123; Connection conn = cp.getConnection(); System.out.println(conn.hashCode()); if(i==5) &#123; conn.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 使用这种读取方法，显得代码十分简便]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm安装hexo卡住怎么办]]></title>
      <url>%2Fblogs%2F2017-02-11%2F89caf779.html</url>
      <content type="text"><![CDATA[用npm安装话经常出现卡住而导致无法正常安装，解决办法就是修改npm的安装源，以下三种方法任选一个即可（正常的朋友不用执行这一步） 1. 通过config命令: npm config set registry http://registry.cnpmjs.orgnpm info underscore （如果上面配置正确这个命令会有字符串response） 2. 命令行指定 npm –registry http://registry.cnpmjs.org info underscore 3. 编辑 ~/.npmrc 加入下面内容 registry = http://registry.cnpmjs.org]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Idea构建Maven项目教程]]></title>
      <url>%2Fblogs%2F2017-02-11%2F3522aeda.html</url>
      <content type="text"><![CDATA[1. 步骤一：配置Idea的maven插件 2. 步骤二：创建maven项目file–&gt;new–&gt;project 3. 步骤三：设置groupid，artifactId 4. 步骤四：设置maven配置 5. 步骤五：设置项目名 6. 步骤六：最后，finish完成构建7. 构建中遇到的问题： jar包下载缓慢解决方案，配置setting.xml为国内阿里云镜像，下载速度秒飞~~ &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;]]></content>
    </entry>

    
  
  
</search>
